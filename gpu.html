<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>28. Delta GPU User Manual &mdash; Cloud Computing Book 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/2.3.2/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap-responsive.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-2.3.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Cloud Computing Book 0.1 documentation" href="index.html" />
    <link rel="prev" title="27. PAPI" href="papi.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="brand" href="index.html">Contents</a>
        <span class="navbar-text pull-left"><b>0.1</b></span>

        <div class="nav-collapse">
          <ul class="nav">
            <li class="divider-vertical"></li>
            
              <li class="dropdown globaltoc-container">
  <a href="index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="todolist.html">1. Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="plan.html">2. Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="title.html">3.   Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="preface.html">4. Preface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="preface.html#citation-for-publications">4.1. Citation for Publications</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#acknowledgement">4.2. Acknowledgement</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#sponsors">4.3. Sponsors</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#about-this-manual">4.4. About this Manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#conventions">4.5. Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">5. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#executive-summary">5.1. Executive Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#project-and-account-application">5.2. Project and Account Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#services">5.3. Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#hardware">5.4. Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#support">5.5. Support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="account.html">6. Project and Account Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="account.html#terminology">6.1. Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#quickstart">6.2. Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#projects-and-accounts-for-xsede-users">6.3. Projects and Accounts for XSEDE users</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#in-depth-information">6.4. In Depth Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#upload-your-ssh-public-key-s">6.5. Upload Your SSH Public Key(s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#openid-integration">6.6. OpenId Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#using-futuregrid-resources">6.7. Using FutureGrid Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#faq-about-accounts">6.8. FAQ about Accounts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="security.html">7. Using SSH keys</a><ul>
<li class="toctree-l2"><a class="reference internal" href="security.html#using-ssh-from-windows">7.1. Using SSH from Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#generate-a-ssh-key">7.2. Generate a SSH key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#add-or-replace-passphrase-for-an-already-generated-key">7.3. Add or Replace Passphrase for an Already Generated Key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#upload-the-key-to-the-futuregrid-portal">7.4. Upload the key to the FutureGrid Portal</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#testing-your-ssh-key">7.5. Testing your ssh key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#testing-your-ssh-key-for-hotel">7.6. Testing your ssh key for Hotel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="status.html">8. Status</a></li>
<li class="toctree-l1"><a class="reference internal" href="hardware.html">9. Hardware</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hardware.html#compute-resources">9.1. Compute Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="hardware.html#networks">9.2. Networks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="hpc.html">10. HPC Services (assigned to Allen and Koji)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#accessing-systems">10.1. Accessing Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#filesystem-layout">10.2. Filesystem Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#modules">10.3. Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#managing-applications-with-torque">10.4. Managing Applications with Torque</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#message-passing-interface-mpi">10.5. Message Passing Interface (MPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#mpi-libraries">10.6. MPI Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#compiling-mpi-applications">10.7. Compiling MPI Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#running-mpi-applications">10.8. Running MPI Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#working-with-hpc-job-services">10.9. Working with HPC Job Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#xray-hpc-services">10.10. Xray HPC Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#storage-services">10.11. Storage Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scalemp.html">11. ScaleMP vSMP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#accessing-scalemp">11.1. Accessing ScaleMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#submitting-a-job">11.2. Submitting a job</a></li>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#developing-a-job-script">11.3. Developing a job script</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openstack.html">12. OpenStack (Gregor)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#get-a-cloud-account">12.1. Get a cloud account</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#commandline-clients">12.2. commandline clients</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openstack-essex.html">13. Using OpenStack on FutureGrid (Gregor)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#note">13.1. NOTE:</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#summary">13.2. Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#getting-started">13.3. Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#log-into-india">13.4. Log into India</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#account-and-credentials">13.5. Account and Credentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#euca2ools-ec2-client-tools">13.6. Euca2ools (EC2 client tools)</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#testing-your-setup">13.7. Testing Your Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#list-of-common-images">13.8. List of Common Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#vm-types">13.9. VM Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#key-management">13.10. Key Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#image-instantiation">13.11. Image Instantiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#better-server-names">13.12. Better Server Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#monitoring-instances">13.13. Monitoring Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#log-into-your-vm">13.14. Log into your VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#nova-volumes-not-available">13.15. Nova Volumes (Not available)</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#volume-snapshots">13.16. Volume Snapshots</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#image-registration">13.17. Image Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#delete-your-images">13.18. Delete your images</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#terminate-your-vms">13.19. Terminate your VMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#limitations">13.20. Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-essex.html#troubleshooting">13.21. Troubleshooting:</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openstack-grizzly.html">14. OpenStack Grizzly (Gregor)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#from-zero-to-get-your-first-instance-running">14.1. From zero to get your first instance running</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#use-block-storage">14.2. Use Block Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#set-up-external-access-to-your-instance">14.3. Set up external access to your instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#make-a-snapshot-of-an-instance">14.4. Make a snapshot of an instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#automate-some-initial-configuration">14.5. Automate some initial configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#get-the-latest-version-of-ubuntu-cloud-image-and-upload-it-to-the-openstack">14.6. Get the latest version of Ubuntu Cloud Image and upload it to the OpenStack</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#delete-your-instance">14.7. Delete your instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#how-to-change-your-password">14.8. How to change your password</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#things-to-do-when-you-need-euca2ools-or-ec2-interfaces">14.9. Things to do when you need Euca2ools or EC2 interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="eucalyptus.html">15. Eucalyptus  (Allen)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#requirements">15.1. Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#account-creation">15.2. Account Creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#resources-overview">15.3. Resources Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#testing-your-setup">15.4. Testing Your Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#image-deployment">15.5. Image Deployment</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#logging-into-the-vm">15.6. Logging Into the VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#vm-network-info">15.7. VM Network Info</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#image-management">15.8. Image Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#status-of-deployments">15.9. Status of Deployments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="iaas.html">16. IaaS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#nimbus-clouds">16.1. Nimbus Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#openstack-clouds">16.2. OpenStack Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#eucalyptus-clouds">16.3. Eucalyptus Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#virtual-appliances-for-training-and-education">16.4. Virtual Appliances for Training and Education</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nimbus.html">17. Using Nimbus on FutureGrid</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#nimbus-on-futuregrid">17.1. Nimbus on FutureGrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#getting-started">17.2. Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#using-the-cloud-client">17.3. Using the Cloud Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#virtual-clusters">17.4. Virtual Clusters</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#cloud-quick-start-launch-a-vm-with-1-command">17.5. Cloud Quick Start : Launch a VM with 1 command</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#launch-a-vm-via-nimbus">17.6. Launch A VM via Nimbus</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#using-other-nimbus-clouds-on-futuregrid">17.7. Using Other Nimbus Clouds on FutureGrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="nimbus.html#launching-multiple-vms">17.8. Launching Multiple VMs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nimbus-phantom.html">18. Nimbus Phantom</a></li>
<li class="toctree-l1"><a class="reference internal" href="nimbus-cloudinitd.html">19. cloudinit.d</a></li>
<li class="toctree-l1"><a class="reference internal" href="precip.html">20. Precip</a><ul>
<li class="toctree-l2"><a class="reference internal" href="precip.html#installation">20.1. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="precip.html#api">20.2. API</a></li>
<li class="toctree-l2"><a class="reference internal" href="precip.html#examples">20.3. Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rain.html">21. RAIN</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rain.html#generate-and-register-an-os-image-on-futuregrid-using-the-fg-shell">21.1. Generate and Register an OS Image on FutureGrid using the FG Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#futuregrid-standalone-image-repository">21.2. FutureGrid Standalone Image Repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#manual-image-customization">21.3. Manual Image Customization</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#rain-manual-pages">21.4. RAIN Manual Pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pegasus.html">22. Pegasus (Matts)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pegasus.html#the-pegasus-run-time-cloud-architecture">22.1. The Pegasus Run-Time Cloud Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="pegasus.html#using-pegasus-on-futuregrid">22.2. Using Pegasus on FutureGrid</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vine.html">23. ViNe (Mauritsio/Renato)</a></li>
<li class="toctree-l1"><a class="reference internal" href="unicore.html">24. Unicore</a><ul>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#unicore-6-on-futuregrid-user-manual">24.1. UNICORE 6 on FutureGrid User Manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#introduction">24.2. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#what-is-unicore">24.3. What is UNICORE?</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#connecting-to-the-unicore-bes-endpoints-from-other-grid-middleware-clients">24.4. Connecting to the UNICORE BES Endpoints From Other Grid Middleware Clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#connecting-to-the-unicore-bes-endpoints-using-a-unicore-commandline-client">24.5. Connecting to the UNICORE BES Endpoints Using a UNICORE Commandline Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#running-jobs-on-unicore-sites">24.6. Running Jobs on UNICORE Sites</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicore.html#deploying-a-new-unicore-6-grid">24.7. Deploying a New UNICORE 6 Grid</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="genesis.html">25. Genesis II</a><ul>
<li class="toctree-l2"><a class="reference internal" href="genesis.html#introduction">25.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="genesis.html#what-is-genesisii">25.2. What is GenesisII</a></li>
<li class="toctree-l2"><a class="reference internal" href="genesis.html#connecting-to-the-genesisii-bes-endpoints">25.3. Connecting to the GenesisII BES Endpoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="genesis.html#using-the-futuregrid-genesisii-endpoints-as-a-client">25.4. Using the Futuregrid GenesisII Endpoints as a Client</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">26. Tutorials (Renato/Mauritsio)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-0-accessing-futuregrid-resources">26.1. Tutorial Topic 0: Accessing FutureGrid Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-1-cloud-provisioning-platforms">26.2. Tutorial Topic 1: Cloud Provisioning Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-2-cloud-run-time-map-reduce-platforms">26.3. Tutorial Topic 2: Cloud Run-time Map/Reduce Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-3-grid-appliances-for-training-education-and-outreach">26.4. Tutorial Topic 3: Grid Appliances for Training, Education, and Outreach</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-4-high-performance-computing">26.5. Tutorial Topic 4: High Performance Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-5-experiment-management">26.6. Tutorial Topic 5: Experiment Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-6-image-management-and-rain">26.7. Tutorial Topic 6: Image Management and Rain</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#tutorial-topic-7-storage">26.8. Tutorial Topic 7:  Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html#other-tutorials-and-educational-materials">26.9. Other Tutorials and Educational Materials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="papi.html">27. PAPI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="papi.html#availability">27.1. Availability</a></li>
<li class="toctree-l2"><a class="reference internal" href="papi.html#references">27.2. References</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">28. Delta GPU User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#running-mpi-gpu-program-on-the-delta-cluster">28.1. Running MPI/GPU program on the Delta cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-programs-on-a-single-gpu">28.2. Running programs on a single GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#c-means-clustering-using-cuda-on-gpu">28.3. C-means clustering using CUDA on GPU</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">28. Delta GPU User Manual</a><ul>
<li><a class="reference internal" href="#running-mpi-gpu-program-on-the-delta-cluster">28.1. Running MPI/GPU program on the Delta cluster</a></li>
<li><a class="reference internal" href="#running-programs-on-a-single-gpu">28.2. Running programs on a single GPU</a></li>
<li><a class="reference internal" href="#c-means-clustering-using-cuda-on-gpu">28.3. C-means clustering using CUDA on GPU</a></li>
</ul>
</li>
</ul>
</ul>
</li>
            
            
              
  <li><a href="papi.html"
         title="previous chapter">&laquo; 27. PAPI</a></li>
            
            
              <li>
  <a href="_sources/gpu.txt"
     rel="nofollow">Source</a></li>
            
          </ul>

          
            
<form class="navbar-search pull-right" action="search.html" method="get">
  <input type="text" name="q" class="search-query" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
      </div>
    </div>
  </div>

<div class="container">
  
  <div class="section" id="delta-gpu-user-manual">
<h1>28. Delta GPU User Manual<a class="headerlink" href="#delta-gpu-user-manual" title="Permalink to this headline">¶</a></h1>
<p>FutureGrid&#8217;s Delta (delta.futuregrid.org), is a 16-node
GPU cluster running Red Hat Linux, with TORQUE (also called PBS) and
Moab for job management, and Module to simplify application and
environment configuration. Delta consists of 16 nodes with two 6-core
Intel X5560 processors at 2.8GHz, 192 GB of DDR3 memory, and 15TB
of RAID5 disk storage. Each node supports 2 nVIDIA Tesla C2070 GPUs
with 448 processing cores. For details on Delta&#8217;s hardware
configuration, see the
<a class="reference external" href="https://portal.futuregrid.org/hardware/delta">Delta</a> page.</p>
<p>The FutureGrid <em>delta</em> cluster is accessible via a batch queue that
is managed from india (india.futuregrid.org). To use delta
interactively, first log into india:</p>
<div class="highlight-python"><pre>ssh username@india.futuregrid.org</pre>
</div>
<p>Then, on india, the following command lets you use one of the delta
compute nodes:</p>
<div class="highlight-python"><pre>qsub -I -q delta myprg</pre>
</div>
<p>If you want to use delta with your job script, please use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#PBS -q delta</span>
</pre></div>
</div>
<p>to indicate that you&#8217;d like to use this queue.</p>
<p>For more details about how to manage queues with qsub, see the Delta
manual page.</p>
<p>Utilization of GPU resources on Delta:
#. Utilize GPU node <a href="#id1"><span class="problematic" id="id2">`</span></a>Running Program on single GPU</p>
<blockquote>
<div>node &lt;<a class="reference external" href="https://portal.futuregrid.org/manual/gpu/running-programs-single-gpu">https://portal.futuregrid.org/manual/gpu/running-programs-single-gpu</a>&gt;`__</div></blockquote>
<ol class="arabic simple">
<li>Utilize GPU cluster
<a class="reference external" href="https://portal.futuregrid.org/manual/running-mpigpu-program-delta-cluster">Running MPI/CUDA program on the Delta
cluster</a></li>
<li>Utilize GPU cloud</li>
<li>Mixing utilization of GPU and CPU</li>
<li>Non-trivial service or applications using GPU</li>
</ol>
<div class="section" id="running-mpi-gpu-program-on-the-delta-cluster">
<h2>28.1. Running MPI/GPU program on the Delta cluster<a class="headerlink" href="#running-mpi-gpu-program-on-the-delta-cluster" title="Permalink to this headline">¶</a></h2>
<p>GPUs provide the ability to use mathematical operations at a fraction
of the cost and with higher performance than on the current generation
of processors. FutureGrid provides the ability to test such an
infrastructure as part of its delta cluster. Here, we provide a
step-by-step guide on how to run a
parallel matrix multiplication program using IntelMPI and CUDA on Delta
machines. The MPI framework distributes the work among compute
nodes, each of which use CUDA to execute the shared workload. We also
provide the complete parallel
matrix multiplication code using MPI/CUDA that has already been tested
on Delta cluster in attachment.</p>
<p>MPI code: pmm_mpi.c:</p>
<div class="highlight-python"><pre>#include &lt;mpi.h&gt;

void invoke_cuda_vecadd();

       int main(int argc, char *argv[])
{
          int rank, size;

          MPI_Init (&amp;argc, &amp;argv); /* starts MPI */
          MPI_Comm_rank (MPI_COMM_WORLD, &amp;rank); /* get current process id */
          MPI_Comm_size (MPI_COMM_WORLD, &amp;size); /* get number of processes */
          invoke_cuda_vecadd();  /* the cuda code */
          MPI_Finalize();
 return 0;
}</pre>
</div>
<p>CUDA code: dgemm_cuda.cu:</p>
<div class="highlight-python"><pre>#include &lt;stdio.h&gt;

__global__ void cuda_vecadd(int *array1, int *array2, int
*array3)
{
     int index = blockIdx.x * blockDim.x + threadIdx.x;
     array3[index] = array1[index] + array2[index];
}

 extern "C" void invoke_cuda_vecadd()
 {
     cudaMalloc((void**) &amp;devarray1, sizeof(int)*10);
     cudaMalloc((void**) &amp;devarray2, sizeof(int)*10);
     cudaMalloc((void**) &amp;devarray3, sizeof(int)*10);
     cudaMemcpy(devarray1, hostarray1, sizeof(int)*10, cudaMemcpyHostToDevice);
     cudaMemcpy(devarray2, hostarray2, sizeof(int)*10, cudaMemcpyHostToDevice);
     cuda_vec_add&lt;&lt;&lt;1, 10&gt;&gt;&gt;(devarray1, devarray2, devarray3);
     cudaMemcpy(hostarray3, devarray3, sizeof(int)*10,  cudaMemcpyDeviceToHost);
     cudaFree(devarray1);
     cudaFree(devarray2);
     cudaFree(devarray3);
 }</pre>
</div>
<p>Note: Mixing MPI and CUDA code may cause problems during linking because
of the difference between C and C++ calling conventions. The use of
extern &#8220;C&#8221; around invoke_cuda_code which instructs the nvcc (a wrapper
of c++) compiler to make that function callable from the C runtime.</p>
<p><strong>Compiling the MPI/CUDA program:</strong></p>
<p>Load the Modules:</p>
<div class="highlight-python"><pre>$ module load IntelMPI # load Intel MPI
$ module load Intel # load icc
$ module load cuda # load cuda tools</pre>
</div>
<p>This will load the Intel MPI, the compiler, and the cuda tools. Next
compile the code with:</p>
<div class="highlight-python"><pre>$ nvcc -c dgemm_cuda.cu -o dgemm_cuda.o
$ mpiicc -o pmm_mpi.c -o pmm_mpi.o
$ mpiicc -o mpicuda pmm_mpi.o dgemm_cuda.o -lcudart -lcublas -L /opt/cuda/lib64 -I /opt/cuda/include</pre>
</div>
<p>Note: The CUDA compiler nvcc is used only to compile the CUDA source
file, and the IntelMPI compiler mpiicc is used to compile the C code and
do the linking</p>
<p><strong>Setting Up and Submitting MPI Jobs:</strong>:</p>
<div class="highlight-python"><pre>qsub -I -l nodes=4 -q delta     # get 4 nodes from FG
uniq /var/spool/torque/aux/399286.i136
gpu_nodes_list    #create machine file list
module load IntelMPI        # load Intel MPI
module load Intel           # load icc
module load cuda           # load cuda tools
mpdboot -r ssh -f gpu_nodes_list -n 4 # will start an mpd ring on 4 nodes including local host
mpiexec -l -machinefile gpu_nodes_list -n 4 ./mpicuda 10000 1 4
# run mpi program using 4 nodes</pre>
</div>
<p><strong>Comparison between four implementations of sequential matrix
multiplication on Delta:</strong></p>
<p><img alt="image79" src="_images/CUBLAS2-800x280.png" /></p>
<p><strong>References:</strong></p>
<ul class="simple">
<li><a class="reference external" href="https://portal.futuregrid.org/sites/default/files/mpi_cuda_mkl.zip">Source Code Package</a></li>
<li>[1] High Performance Computing using CUDA,2009 User Group Conference</li>
<li>[2] <a class="reference external" href="http://www.nvidia.com/content/global/global.php">http://www.nvidia.com/content/global/global.php</a></li>
</ul>
<p>To get source code: git clone <a class="reference external" href="mailto:git&#37;&#52;&#48;github&#46;com">git<span>&#64;</span>github<span>&#46;</span>com</a>:futuregrid/GPU.git</p>
<p>Compiling source code on Delta machine:</p>
<div class="highlight-python"><pre>module load intelmpi
module load intel
module load cuda
cd mpi_cuda_mkl
make</pre>
</div>
</div>
<div class="section" id="running-programs-on-a-single-gpu">
<h2>28.2. Running programs on a single GPU<a class="headerlink" href="#running-programs-on-a-single-gpu" title="Permalink to this headline">¶</a></h2>
<p>GPUs provide the ability to use mathematical operations at a
fraction of the cost and with higher performance than on the
current generation of processors. CUDA is a parallel programming model
and software environment that leverages the parallel computational power
of GPU for non-graphics computing in a fraction of the time required on
a CPU. FutureGrid provides the ability to test such a hardware and
software environment as part of its Delta cluster. Here, we illustrate
some details of data-parallel computational model of CUDA, and then
provide a step-by-step guide on how to make a parallel matrix
multiplication program using CUDA. In the supplied attachment, we also
provide the complete code that has already been tested on Delta node.</p>
<p><img alt="image80" src="_images/cudaarchi_threadsmode-544x300.png" />
Figure 1: GPU Kernel and Thread model [1]</p>
<p><strong>CUDA Kernel and Threads:</strong></p>
<p>The fundamental part of the CUDA code is the kernel program.
Kernel is the function that can be executed in parallel in the GPU
device. A CUDA kernel is executed by an array of CUDA threads. All
threads run the same code. Each thread has an ID that it uses to compute
memory address and make a control decision. CUDA supports to run
thousands of threads on the GPU. CUDA organizes thousands
of threads into a hierarchy of a grid of thread blocks. A grid is a set
of thread blocks that can be processed on the device in parallel. A
thread block is a set of concurrent threads that can cooperate among
themselves through a synchronization barrier and access to a shared
memory space private to the block. Each thread is given a unique thread
ID— thread.Idx within its thread block. Each thread block is given a
unique block ID— block.Idx within its grid.</p>
<p><strong>CUDA Kernel code for Matrix Multiplication:</strong>:</p>
<div class="highlight-python"><pre>__global__ void matrixMul( float* C, float* A, float* B, int
wA, int wB)
 {
   // Block index
      int bx = blockIdx.x;
      int by = blockIdx.y;
   // Thread index
      int tx = threadIdx.x;
      int ty = threadIdx.y;

   // Index of the first sub-matrix of A processed by the block
      int aBegin = wA * BLOCK_SIZE * by;
   // Index of the last sub-matrix of A processed by the block
      int aEnd  = aBegin + wA - 1;
   // Step size used to iterate through the sub-matrices of A
      int aStep  = BLOCK_SIZE;
   // Index of the first sub-matrix of B processed by the block
      int bBegin = BLOCK_SIZE * bx;
   // Step size used to iterate through the sub-matrices of B
      int bStep  = BLOCK_SIZE * wB;
   // Csub is used to store the element of the block
sub-matrix that is computed by the thread
   float Csub = 0;
   // Loop over all the sub-matrices of A and B required to compute the block sub-matrix
   for (int a = aBegin, b = bBegin; a &lt;= aEnd; a += aStep, b += bStep) {
      // Declaration of the shared memory array As used to store the sub-matrix of A
      __shared__ float As[BLOCK_SIZE][BLOCK_SIZE];
      // Declaration of the shared memory array Bs used to store the sub-matrix of B
      __shared__ float Bs[BLOCK_SIZE][BLOCK_SIZE];
      As[ty][tx] = A[a + wA * ty + tx];
        Bs[ty],[tx] = B[b + wB * ty + tx];
      // Synchronize to make sure the matrices are loaded

__syncthreads();
     // multiply two matrices together; each thread computes one element of sub-matrix
 #pragma unroll
      for (int k = 0; k &lt; BLOCK_SIZE; ++k)
            Csub += As[ty][k] * Bs[k][tx];


      // Synchronize to make sure that the preceding computation is done

__syncthreads();

}
   // Write the block sub-matrix to device memory; each thread only writes one element!
    int c = wB * BLOCK_SIZE * by + BLOCK_SIZE * bx;
    C[c + wB * ty + tx] = Csub;
}</pre>
</div>
<p><img alt="image81" src="_images/cudaMemoryArchitecture-500x173.png" />
Figure 2: GPU memory architecture [1][1] [1]</p>
<p><strong>CUDA Memory Architecture:</strong></p>
<p>All multiprocessors of the GPU device access a large global
device memory for both gather and scatter operations. This memory is
relatively slow because it does not provide caching. Shared memory is
fast compared to device memory, and normally takes the same amount of
time as required to access registers. Shared memory is “local” to each
multiprocessor unlike device memory and allows more efficient local
synchronization. It is divided into many parts. Each thread block within
a multiprocessor accesses its own part of shared memory, and this part
of shared memory is not accessible by any other thread block of this
multiprocessor or of some other multiprocessor. All threads within a
thread block that have the same lifetime as the block share this part of
memory for both read and write operations. To declare variables in
shared memory, __shared__ qualifier is used, and to declare in
global memory, __device__ qualifier is used.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">this code has wrong tabs</p>
</div>
<p><strong>CPU code invoke CUDA kernel code:</strong>:</p>
<div class="highlight-python"><pre>void invoke_matrixMul(int size){

      int devID;
      cudaDeviceProp props;
      checkCudaErrors(cudaGetDevice(&amp;devID));
      checkCudaErrors(cudaGetDeviceProperties(&amp;props, devID));

      int block_size = (props.major &lt; 2) ? 16 : 32;
      unsigned int uiWA, uiHA, uiWB, uiHB, uiWC, uiHC;
      uiWA = uiHA= uiWB = uiHB = uiWC = uiHC;

   // allocate host memory for matrices A and B
   unsigned int size_A = uiWA * uiHA;
   unsigned int mem_size_A = sizeof(float) * size_A;
   float* h_A = (float*)malloc(mem_size_A);
   unsigned int size_B = uiWB * uiHB;
   unsigned int mem_size_B = sizeof(float) * size_B;
   float* h_B = (float*)malloc(mem_size_B);

   // initialize host memory
      srand(2012);
      randomInit(h_A, size_A);
      randomInit(h_B, size_B);

   // allocate device memory
   float* d_A, *d_B, *d_C;
   unsigned int size_C = uiWC * uiHC;
   unsigned int mem_size_C = sizeof(float) * size_C;

   // allocate host memory for the result
   float* h_C    = (float*) malloc(mem_size_C);
   float* h_CUBLAS = (float*)    malloc(mem_size_C);
      checkCudaErrors(cudaMalloc((void**) &amp;d_A, mem_size_A));
      checkCudaErrors(cudaMalloc((void**) &amp;d_B, mem_size_B));
   // copy host memory to device
     checkCudaErrors(cudaMemcpy(d_A, h_A, mem_size_A, cudaMemcpyHostToDevice) );
     checkCudaErrors(cudaMemcpy(d_B, h_B, mem_size_B, cudaMemcpyHostToDevice) );
     checkCudaErrors(cudaMalloc((void**) &amp;d_C, mem_size_C));
   // setup execution parameters
      dim3 threads(block_size, block_size);
      dim3 grid(uiWC / threads.x, uiHC / threads.y);


   //Performs warmup operation using matrixMul CUDA kernel
   if (block_size 16) {
          matrixMul&lt;16&gt;&lt;&lt;&lt; grid, threads &gt;&gt;&gt;(d_C, d_A, d_B, uiWA, uiWB);
   } else {
         matrixMul&lt;32&gt;&lt;&lt;&lt; grid, threads &gt;&gt;&gt;(d_C, d_A, d_B, uiWA, uiWB);

   }


   cudaDeviceSynchronize();
   // clean up memory
   free(h_A);
   free(h_B);
   free(h_C);
 }</pre>
</div>
<p><strong>References:</strong>
[1] High Performance Computing with CUDA, 2009 User Group Conference
[2] <a class="reference external" href="http://www.nvidia.com/content/global/global.php">http://www.nvidia.com/content/global/global.php</a></p>
<p>source code: git clone <a class="reference external" href="mailto:git&#37;&#52;&#48;github&#46;com">git<span>&#64;</span>github<span>&#46;</span>com</a>:futuregrid/GPU.git</p>
<p>Usage:</p>
<div class="highlight-python"><pre>module load cuda
module load intel
nvcc -c matrixMul.cu -L/opt/cuda/lib64 -lcudart</pre>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="89%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attachment</th>
<th class="head">Size</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="https://portal.futuregrid.org/sites/default/files/matrixMul_0.zip">matrixMul.zip</a></td>
<td>3.13 KB</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="c-means-clustering-using-cuda-on-gpu">
<h2>28.3. C-means clustering using CUDA on GPU<a class="headerlink" href="#c-means-clustering-using-cuda-on-gpu" title="Permalink to this headline">¶</a></h2>
<p>The computational demands for multivariate clustering are
increasing rapidly, and therefore processing large data sets is
time consuming on a single CPU. To address the computational demands, we
implemented the cmeans clustering algorithm, using the NVIDIA&#8217;s CUDA&#8217;s
framework and the latest GPU devices on the Delta machine.</p>
<dl class="docutils">
<dt><strong>Fuzzy C-Means Clustering</strong></dt>
<dd>Fuzzy c-means is an algorithm of clustering which allows one element</dd>
</dl>
<p>to belong to two or more clusters with different probability. This
method is frequently used in multivariate clustering. This algorithm is
based on minimization of the following objective function: <img alt="image82" src="_images/cmeans_objective_function.gif" />
Here, M is a real number greater than 1, N is the number of elements,
Uij is the value of membership of Xi in cluster Cj,  xi is the ith of
d-dimensional measured data, cj is the d-dimension center of the
cluster, and ||Xi-Cj|| is any norm expressing the similarity between
any measured data and the center.  Fuzzy partitioning is performed
through an iterative optimization of the objective function shown above.
Within each iteration, the algorithm updates the membership uij and the
cluster centers cj by:
<img alt="image83" src="_images/cmeans_uij_ck.gif" />    <img alt="image84" src="_images/cmeans_ck.gif" />
This iteration will stop when <img alt="image85" src="_images/cmeans_stop_condition.gif" />, where &#8216;e&#8217; is a termination
criterion between 0 and 1, and k represents the iteration steps.</p>
<p><strong>Algorithm of CUDA C-means:</strong>
#. Copy data to GPU
#. DistanceMatrix kernel
#. MembershipMatrix kernel
#. UpdateCenters kernel, copy partial centers to host from GPUs
#. ClusterSizes kernel, copy cluster sizes to host from each GPU
#. Aggregate partial cluster centers and reduce
#. Compute difference between current cluster centers and previous
#. Compute cluster distance and memberships using final centers.
#. DistanceMatrix
#. MembershipMatrix
#. UpdateCetners
#. ClusterSizes</p>
<p><strong>CUDA C-means performance on Delta:</strong>
<img alt="image86" src="_images/cmeansPerformance2-600x178.png" />
Figure 1: C-means performance using GPU and CPU</p>
<p>References</p>
<ul class="simple">
<li>[1]`http://en.wikipedia.org/wiki/Cluster_analysis &lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Cluster_analysis">http://en.wikipedia.org/wiki/Cluster_analysis</a>&gt;`__</li>
<li>[2] Scalable Data Clustering using GPU Clusters,  Andrew Pangborn, Gregor von Laszewski</li>
</ul>
</div>
</div>


</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>